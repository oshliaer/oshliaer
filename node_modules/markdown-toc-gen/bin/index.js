#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const fs_1 = require("fs");
const yargs_1 = __importDefault(require("yargs"));
const di_container_1 = require("./src/di-container");
const toc_1 = require("./src/toc/toc");
const utils_1 = require("./src/utils/utils");
const process_1 = require("process");
var Command;
(function (Command) {
    Command["INSERT"] = "insert";
    Command["DRYRUN"] = "dryrun";
    Command["CHECK"] = "check";
})(Command || (Command = {}));
yargs_1.default(process.argv.slice(2))
    .scriptName('markdown-toc-gen')
    .usage('Usage: $0 <command> [options]')
    .example('$0 insert README.md', 'insert table of content for README.md')
    .example('$0 insert ./**/README.md', 'insert table of content for given README.md files')
    .example('$0 update README.md', 'update existing table of content for README.md')
    .example('$0 dry-run README.md', 'test toc creation for given README.md')
    .example('$0 dry-run ./**/README.md', 'test toc creation for given README.md files')
    .example('$0 check ./**/README.md', 'validates toc for given README.md files')
    .option('d', {
    alias: 'max-depth',
    describe: 'max depth for header parsing (default: 6)',
    type: 'number',
})
    .command(['insert [files..]', 'update'], 'insert/update the toc in given markdown file', {}, (argv) => execCommand(Command.INSERT, argv))
    .command(['dry-run [files..]'], 'returns only created markdown toc without changing given file', {}, (argv) => execCommand(Command.DRYRUN, argv))
    .command(['check [files..]'], 'check if toc exists or if toc is outdated', {}, (argv) => execCommand(Command.CHECK, argv))
    .demandCommand()
    .recommendCommands()
    .strict()
    .wrap(120)
    .help('h')
    .alias('h', 'help')
    .epilog('Copyright 2021 by TheSilk')
    .epilog('Released under MIT License')
    .version()
    .help().argv;
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
function execCommand(cmd, argv) {
    const toc = new di_container_1.DiContainer().diContainer.resolve(toc_1.Toc);
    let globalValid = true;
    let filePath;
    for (filePath of argv.files) {
        if (!filePath.includes('node_modules')) {
            const maxDepth = argv.maxDepth;
            if (fs_1.existsSync(filePath)) {
                if (maxDepth) {
                    toc.maxDepth = maxDepth;
                }
                toc.filePath = filePath;
                switch (cmd) {
                    case Command.INSERT:
                        utils_1.log(`generating toc for ${filePath}`, utils_1.Color.BLUE);
                        try {
                            toc.insertToc();
                        }
                        catch (e) {
                            utils_1.log(e.message, utils_1.Color.YELLOW);
                        }
                        break;
                    case Command.DRYRUN:
                        utils_1.log(`generating toc for ${filePath} without updating/insertion`, utils_1.Color.BLUE);
                        utils_1.log(toc.createToc());
                        break;
                    case Command.CHECK: {
                        const isValid = toc.isTocValid();
                        globalValid = globalValid && isValid;
                        isValid
                            ? utils_1.log(`validation of ${filePath} passed`, utils_1.Color.GREEN)
                            : utils_1.log(`validation of ${filePath} failed`, utils_1.Color.RED);
                        break;
                    }
                }
            }
        }
    }
    if (cmd === Command.CHECK) {
        if (globalValid) {
            utils_1.log('validation passed', utils_1.Color.GREEN);
            process_1.exit(0);
        }
        utils_1.log('validation failed', utils_1.Color.RED);
        process_1.exit(1);
    }
}
