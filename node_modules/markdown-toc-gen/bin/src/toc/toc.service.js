"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TocService = void 0;
const inversify_1 = require("inversify");
const jest_diff_1 = require("jest-diff");
require("reflect-metadata");
/* eslint-disable-next-line no-control-regex */
/**
 * TocService
 * provides method to parse and validate toc
 */
let TocService = class TocService {
    constructor() {
        this._tocPlaceholder = new RegExp('<!--\\s?toc\\s?-->(?<toc>(?:.*\\r?\\n)+)<!--\\s?tocstop\\s?-->');
    }
    /**
     * creates unique id link
     * @param caption - heading title
     * @param counter - amount of repetition of given caption (optional)
     * @returns - unique id link
     */
    createLink(caption, counter) {
        if (counter) {
            return `(#${this.toLinkId(caption)}-${counter})`;
        }
        return `(#${this.toLinkId(caption)})`;
    }
    /**
     * parses and validates toc in given markdown file and evaluates given toc with generated toc
     * @return toc validation
     */
    validateToc(parsedToc, expectedToc) {
        const diffHeadings = this.getDiffHeadings(parsedToc.split('\n').filter((item) => item), expectedToc.split('\n').filter((item) => item));
        if (diffHeadings) {
            return diffHeadings;
        }
        return null;
    }
    /**
     * finds and parses table of content in given markdown file
     * @returns parsed table of content
     */
    parseToc(content) {
        const match = this._tocPlaceholder.exec(content);
        if (match && match.groups && match.groups.toc) {
            return match.groups.toc;
        }
        return '';
    }
    /**
     * get diff for the headings between the parsed table of contend and the parsed headings
     * @param parsedTOCHeadings - parsed existing table of content
     * @param parsedHeadings - table of contents which is created out of the parsed headings
     * @returns diff for existing and created table of content
     */
    getDiffHeadings(parsedTOCHeadings, parsedHeadings) {
        const diffHeadings = jest_diff_1.diffLinesRaw(parsedTOCHeadings, parsedHeadings);
        if (diffHeadings.filter((val) => val['0'] !== 0).length > 0) {
            return jest_diff_1.diffLinesUnified(parsedTOCHeadings, parsedHeadings);
        }
        return null;
    }
    /**
     * transform given string to gfm link id
     * @param str - given string which should be transformed
     * @returns - transformed string
     */
    toLinkId(str) {
        return str
            .replace(/[\s_]+/g, '-')
            .replace(/[^a-zA-Z0-9-]*/g, '')
            .toLowerCase();
    }
};
TocService = __decorate([
    inversify_1.injectable()
], TocService);
exports.TocService = TocService;
